# -*- coding: utf-8 -*-
"""50 ejercicios Sesion 19.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1QVUhcTzD_lyx_ikzkBinR_wUdOa9OkMu

### Ejercicio 1. Balanceo de paréntesis

**Enunciado:** Implementa una función que verifique si los paréntesis, corchetes y llaves en una expresión están correctamente balanceados.
"""

# Ejercicio 1: Balanceo de paréntesis
# Enunciado: Implementa una función que verifique si los paréntesis, corchetes y llaves en una expresión están correctamente balanceados.
#
# Implementación:

def balanceo_parentesis(expresion):
    pila = []
    parejas = {')': '(', ']': '[', '}': '{'}

    for caracter in expresion:
        if caracter in '([{':
            pila.append(caracter)
        elif caracter in ')]}':
            if not pila or pila[-1] != parejas[caracter]:
                return False
            pila.pop()

    return len(pila) == 0

# Prueba
print(balanceo_parentesis("({[]})"))  # True
print(balanceo_parentesis("({[})"))   # False

"""### Ejercicio 2. Conversión infijo a postfijo

**Enunciado:** Convierte una expresión matemática infija a notación postfija.
"""

# Ejercicio 2: Conversión infijo a postfijo
# Enunciado: Convierte una expresión matemática infija a notación postfija.
#
# Implementación:

def infijo_a_postfijo(expresion):
    precedencia = {'+': 1, '-': 1, '*': 2, '/': 2, '^': 3}
    pila = []
    salida = []

    for token in expresion.split():
        if token.isalnum():
            salida.append(token)
        elif token == '(':
            pila.append(token)
        elif token == ')':
            while pila and pila[-1] != '(':
                salida.append(pila.pop())
            pila.pop()
        else:
            while (pila and pila[-1] != '(' and
                   precedencia.get(token, 0) <= precedencia.get(pila[-1], 0)):
                salida.append(pila.pop())
            pila.append(token)

    while pila:
        salida.append(pila.pop())

    return ' '.join(salida)

# Prueba
print(infijo_a_postfijo("( A + B ) * C"))  # A B + C *

"""### Ejercicio 3. Evaluar expresión postfija

**Enunciado:** Evalúa una expresión matemática en notación postfija.
"""

# Ejercicio 3: Evaluar expresión postfija
# Enunciado: Evalúa una expresión matemática en notación postfija.
#
# Implementación:

def evaluar_postfijo(expresion):
    pila = []

    for token in expresion.split():
        if token.isdigit():
            pila.append(int(token))
        else:
            b = pila.pop()
            a = pila.pop()
            if token == '+': pila.append(a + b)
            elif token == '-': pila.append(a - b)
            elif token == '*': pila.append(a * b)
            elif token == '/': pila.append(a / b)

    return pila[0]

# Prueba
print(evaluar_postfijo("3 4 + 2 *"))  # 14

"""### Ejercicio 4. Invertir una lista usando pila

**Enunciado:** Invierte una lista usando operaciones de pila.
"""

# Ejercicio 4: Invertir una lista usando pila
# Enunciado: Invierte una lista usando operaciones de pila.
#
# Implementación:

def invertir_lista_pila(lista):
    pila = []
    # Push todos los elementos a la pila
    for elemento in lista:
        pila.append(elemento)

    # Pop todos los elementos (saldrán en orden inverso)
    lista_invertida = []
    while pila:
        lista_invertida.append(pila.pop())

    return lista_invertida

# Prueba
print(invertir_lista_pila([1, 2, 3, 4, 5]))  # [5, 4, 3, 2, 1]

"""### Ejercicio 5. Eliminar elementos consecutivos duplicados

**Enunciado:** Elimina elementos duplicados consecutivos usando una pila.
"""

# Ejercicio 5: Eliminar elementos consecutivos duplicados
# Enunciado: Elimina elementos duplicados consecutivos usando una pila.
#
# Implementación:

def eliminar_consecutivos_duplicados(lista):
    pila = []

    for elemento in lista:
        if not pila or pila[-1] != elemento:
            pila.append(elemento)

    return pila

# Prueba
print(eliminar_consecutivos_duplicados([1, 2, 2, 3, 4, 4, 4, 5]))  # [1, 2, 3, 4, 5]

"""### Ejercicio 6. Siguiente elemento mayor

**Enunciado:** Para cada elemento, encuentra el primer elemento mayor a su derecha.
"""

# Ejercicio 6: Siguiente elemento mayor
# Enunciado: Para cada elemento, encuentra el primer elemento mayor a su derecha.
#
# Implementación:

def siguiente_elemento_mayor(lista):
    pila = []
    resultado = [-1] * len(lista)

    for i in range(len(lista)):
        while pila and lista[pila[-1]] < lista[i]:
            idx = pila.pop()
            resultado[idx] = lista[i]
        pila.append(i)

    return resultado

# Prueba
print(siguiente_elemento_mayor([4, 5, 2, 10]))  # [5, 10, 10, -1]

"""### Ejercicio 7. Validar secuencia de push/pop

**Enunciado:** Verifica si una secuencia es válida para operaciones push/pop.
"""

# Ejercicio 7: Validar secuencia de push/pop
# Enunciado: Verifica si una secuencia es válida para operaciones push/pop.
#
# Implementación:

def validar_secuencia_push_pop(push_seq, pop_seq):
    pila = []
    i = 0

    for num in push_seq:
        pila.append(num)
        while pila and pila[-1] == pop_seq[i]:
            pila.pop()
            i += 1

    return not pila

# Prueba
print(validar_secuencia_push_pop([1, 2, 3, 4, 5], [4, 5, 3, 2, 1]))  # True

"""### Ejercicio 8. Pila con mínimo en O(1)

**Enunciado:** Implementa una pila que devuelva el mínimo en tiempo constante.
"""

# Ejercicio 8: Pila con mínimo en O(1)
# Enunciado: Implementa una pila que devuelva el mínimo en tiempo constante.
#
# Implementación:

class PilaConMinimo:
    def __init__(self):
        self.pila_principal = []
        self.pila_minimos = []

    def push(self, valor):
        self.pila_principal.append(valor)
        if not self.pila_minimos or valor <= self.pila_minimos[-1]:
            self.pila_minimos.append(valor)

    def pop(self):
        if not self.pila_principal:
            return None
        valor = self.pila_principal.pop()
        if valor == self.pila_minimos[-1]:
            self.pila_minimos.pop()
        return valor

    def min(self):
        return self.pila_minimos[-1] if self.pila_minimos else None

# Prueba
pila = PilaConMinimo()
pila.push(3)
pila.push(1)
pila.push(2)
print(pila.min())  # 1

"""### Ejercicio 9. Dos pilas en un array

**Enunciado:** Implementa dos pilas usando un solo array.
"""

# Ejercicio 9: Dos pilas en un array
# Enunciado: Implementa dos pilas usando un solo array.
#
# Implementación:

class DosPilas:
    def __init__(self, capacidad):
        self.capacidad = capacidad
        self.array = [None] * capacidad
        self.top1 = -1
        self.top2 = capacidad

    def push1(self, valor):
        if self.top1 < self.top2 - 1:
            self.top1 += 1
            self.array[self.top1] = valor
        else:
            print("Pila 1 llena")

    def push2(self, valor):
        if self.top1 < self.top2 - 1:
            self.top2 -= 1
            self.array[self.top2] = valor
        else:
            print("Pila 2 llena")

    def pop1(self):
        if self.top1 >= 0:
            valor = self.array[self.top1]
            self.top1 -= 1
            return valor
        return None

    def pop2(self):
        if self.top2 < self.capacidad:
            valor = self.array[self.top2]
            self.top2 += 1
            return valor
        return None

# Prueba
pilas = DosPilas(5)
pilas.push1(1)
pilas.push2(2)
print(pilas.pop1())  # 1

"""### Ejercicio 10. Ordenar pila

**Enunciado:** Ordena una pila usando solo operaciones de pila.
"""

# Ejercicio 10: Ordenar pila
# Enunciado: Ordena una pila usando solo operaciones de pila.
#
# Implementación:

def ordenar_pila(pila):
    pila_temp = []

    while pila:
        temp = pila.pop()
        while pila_temp and pila_temp[-1] > temp:
            pila.append(pila_temp.pop())
        pila_temp.append(temp)

    return pila_temp

# Prueba
pila = [3, 1, 4, 2]
print(ordenar_pila(pila))  # [1, 2, 3, 4]

"""### Ejercicio 11. Implementar cola usando pilas

**Enunciado:** Implementa una cola usando dos pilas.
"""

# Ejercicio 11: Implementar cola usando pilas
# Enunciado: Implementa una cola usando dos pilas.
#
# Implementación:

class ColaConPilas:
    def __init__(self):
        self.entrada = []
        self.salida = []

    def enqueue(self, valor):
        self.entrada.append(valor)

    def dequeue(self):
        if not self.salida:
            while self.entrada:
                self.salida.append(self.entrada.pop())
        return self.salida.pop() if self.salida else None

    def front(self):
        if not self.salida:
            while self.entrada:
                self.salida.append(self.entrada.pop())
        return self.salida[-1] if self.salida else None

# Prueba
cola = ColaConPilas()
cola.enqueue(1)
cola.enqueue(2)
print(cola.dequeue())  # 1

"""### Ejercicio 12. Cola circular

**Enunciado:** Implementa una cola circular con array de tamaño fijo.
"""

# Ejercicio 12: Cola circular
# Enunciado: Implementa una cola circular con array de tamaño fijo.
#
# Implementación:

class ColaCircular:
    def __init__(self, capacidad):
        self.capacidad = capacidad
        self.cola = [None] * capacidad
        self.frente = 0
        self.final = -1
        self.tamaño = 0

    def enqueue(self, valor):
        if self.tamaño == self.capacidad:
            return False
        self.final = (self.final + 1) % self.capacidad
        self.cola[self.final] = valor
        self.tamaño += 1
        return True

    def dequeue(self):
        if self.tamaño == 0:
            return None
        valor = self.cola[self.frente]
        self.frente = (self.frente + 1) % self.capacidad
        self.tamaño -= 1
        return valor

    def front(self):
        return self.cola[self.frente] if self.tamaño > 0 else None

# Prueba
cola = ColaCircular(3)
cola.enqueue(1)
cola.enqueue(2)
print(cola.dequeue())  # 1

"""### Ejercicio 13. Revertir primeros k elementos

**Enunciado:** Invierte los primeros k elementos de una cola.
"""

# Ejercicio 13: Revertir primeros k elementos
# Enunciado: Invierte los primeros k elementos de una cola.
#
# Implementación:

def revertir_primeros_k(cola, k):
    pila = []

    # Sacar primeros k elementos a la pila
    for _ in range(k):
        pila.append(cola.dequeue())

    # Devolver de la pila a la cola (invertidos)
    while pila:
        cola.enqueue(pila.pop())

    # Mover los elementos restantes al final
    for _ in range(len(cola) - k):
        cola.enqueue(cola.dequeue())

    return cola

# Prueba (asumiendo implementación básica de cola)
class ColaSimple:
    def __init__(self):
        self.elementos = []

    def enqueue(self, valor):
        self.elementos.append(valor)

    def dequeue(self):
        return self.elementos.pop(0) if self.elementos else None

    def __len__(self):
        return len(self.elementos)

cola = ColaSimple()
for i in range(1, 6):
    cola.enqueue(i)
revertir_primeros_k(cola, 3)

"""### Ejercicio 14. Generar números binarios

**Enunciado:** Genera los primeros n números binarios usando una cola.
"""

# Ejercicio 14: Generar números binarios
# Enunciado: Genera los primeros n números binarios usando una cola.
#
# Implementación:

def generar_numeros_binarios(n):
    if n <= 0:
        return []

    resultado = []
    cola = []
    cola.append("1")

    for _ in range(n):
        actual = cola.pop(0)
        resultado.append(actual)
        cola.append(actual + "0")
        cola.append(actual + "1")

    return resultado

# Prueba
print(generar_numeros_binarios(5))  # ['1', '10', '11', '100', '101']

"""### Ejercicio 15. Cola de prioridad simple

**Enunciado:** Implementa una cola de prioridad usando listas.
"""

# Ejercicio 15: Cola de prioridad simple
# Enunciado: Implementa una cola de prioridad usando listas.
#
# Implementación:

class ColaPrioridadSimple:
    def __init__(self):
        self.elementos = []

    def enqueue(self, valor, prioridad):
        self.elementos.append((valor, prioridad))
        # Ordenar por prioridad (menor número = mayor prioridad)
        self.elementos.sort(key=lambda x: x[1])

    def dequeue(self):
        if not self.elementos:
            return None
        return self.elementos.pop(0)[0]

    def front(self):
        return self.elementos[0][0] if self.elementos else None

# Prueba
cp = ColaPrioridadSimple()
cp.enqueue("tarea1", 2)
cp.enqueue("tarea2", 1)
print(cp.dequeue())  # tarea2

"""### Ejercicio 16. Cola con dos stacks eficiente

**Enunciado:** Implementa una cola eficiente usando dos stacks.
"""

# Ejercicio 16: Cola con dos stacks eficiente
# Enunciado: Implementa una cola eficiente usando dos stacks.
#
# Implementación:

class ColaEficiente:
    def __init__(self):
        self.stack_entrada = []
        self.stack_salida = []

    def enqueue(self, valor):
        self.stack_entrada.append(valor)

    def dequeue(self):
        if not self.stack_salida:
            self._transferir()
        return self.stack_salida.pop() if self.stack_salida else None

    def _transferir(self):
        while self.stack_entrada:
            self.stack_salida.append(self.stack_entrada.pop())

    def front(self):
        if not self.stack_salida:
            self._transferir()
        return self.stack_salida[-1] if self.stack_salida else None

# Prueba
cola = ColaEficiente()
cola.enqueue(1)
cola.enqueue(2)
print(cola.dequeue())  # 1

"""### Ejercicio 17. Intercalar colas

**Enunciado:** Intercala elementos de dos colas en una nueva cola.
"""

# Ejercicio 17: Intercalar colas
# Enunciado: Intercala elementos de dos colas en una nueva cola.
#
# Implementación:

def intercalar_colas(cola1, cola2):
    resultado = []

    while cola1 and cola2:
        resultado.append(cola1.pop(0))
        resultado.append(cola2.pop(0))

    # Agregar elementos restantes
    resultado.extend(cola1)
    resultado.extend(cola2)

    return resultado

# Prueba
print(intercalar_colas([1, 3, 5], [2, 4, 6, 8]))  # [1, 2, 3, 4, 5, 6, 8]

"""### Ejercicio 18. Revertir cola recursivamente

**Enunciado:** Revierte una cola usando recursión.
"""

# Ejercicio 18: Revertir cola recursivamente
# Enunciado: Revierte una cola usando recursión.
#
# Implementación:

def revertir_cola_recursiva(cola):
    if not cola:
        return

    # Sacar el frente
    frente = cola.pop(0)

    # Revertir el resto recursivamente
    revertir_cola_recursiva(cola)

    # Poner el frente al final
    cola.append(frente)

# Prueba
cola = [1, 2, 3, 4, 5]
revertir_cola_recursiva(cola)
print(cola)  # [5, 4, 3, 2, 1]

"""### Ejercicio 19. Problema del puente

**Enunciado:** Simula el cruce de vehículos por un puente de capacidad limitada.
"""

# Ejercicio 19: Problema del puente
# Enunciado: Simula el cruce de vehículos por un puente de capacidad limitada.
#
# Implementación:

class Puente:
    def __init__(self, capacidad):
        self.capacidad = capacidad
        self.cola_entrada = []
        self.puente = []

    def llegar_vehiculo(self, vehiculo):
        if len(self.puente) < self.capacidad:
            self.puente.append(vehiculo)
            print(f"{vehiculo} entra al puente")
        else:
            self.cola_entrada.append(vehiculo)
            print(f"{vehiculo} espera en cola")

    def salir_vehiculo(self):
        if self.puente:
            vehiculo = self.puente.pop(0)
            print(f"{vehiculo} sale del puente")

            # Si hay vehículos esperando, dejar pasar uno
            if self.cola_entrada:
                siguiente = self.cola_entrada.pop(0)
                self.puente.append(siguiente)
                print(f"{siguiente} entra al puente")
        return vehiculo

# Prueba
puente = Puente(2)
puente.llegar_vehiculo("Auto1")
puente.llegar_vehiculo("Auto2")
puente.llegar_vehiculo("Auto3")
puente.salir_vehiculo()

"""### Ejercicio 20. Cola con máximo

**Enunciado:** Implementa una cola que pueda devolver el elemento máximo en O(1).
"""

# Ejercicio 20: Cola con máximo
# Enunciado: Implementa una cola que pueda devolver el elemento máximo en O(1).
#
# Implementación:

from collections import deque

class ColaConMaximo:
    def __init__(self):
        self.cola_principal = deque()
        self.cola_maximos = deque()

    def enqueue(self, valor):
        self.cola_principal.append(valor)

        # Mantener cola de máximos
        while self.cola_maximos and self.cola_maximos[-1] < valor:
            self.cola_maximos.pop()
        self.cola_maximos.append(valor)

    def dequeue(self):
        if not self.cola_principal:
            return None

        valor = self.cola_principal.popleft()
        if valor == self.cola_maximos[0]:
            self.cola_maximos.popleft()

        return valor

    def max(self):
        return self.cola_maximos[0] if self.cola_maximos else None

# Prueba
cola = ColaConMaximo()
cola.enqueue(3)
cola.enqueue(1)
cola.enqueue(2)
print(cola.max())  # 3

"""### Ejercicio 21. Intersección de listas ordenadas

**Enunciado:** Encuentra la intersección de dos listas ordenadas.
"""

# Ejercicio 21: Intersección de listas ordenadas
# Enunciado: Encuentra la intersección de dos listas ordenadas.
#
# Implementación:

def interseccion_listas_ordenadas(lista1, lista2):
    i, j = 0, 0
    resultado = []

    while i < len(lista1) and j < len(lista2):
        if lista1[i] == lista2[j]:
            resultado.append(lista1[i])
            i += 1
            j += 1
        elif lista1[i] < lista2[j]:
            i += 1
        else:
            j += 1

    return resultado

# Prueba
print(interseccion_listas_ordenadas([1, 2, 3, 4], [2, 4, 6]))  # [2, 4]

"""### Ejercicio 22. Unión de listas ordenadas

**Enunciado:** Encuentra la unión de dos listas ordenadas.
"""

# Ejercicio 22: Unión de listas ordenadas
# Enunciado: Encuentra la unión de dos listas ordenadas.
#
# Implementación:

def union_listas_ordenadas(lista1, lista2):
    i, j = 0, 0
    resultado = []

    while i < len(lista1) and j < len(lista2):
        if lista1[i] < lista2[j]:
            resultado.append(lista1[i])
            i += 1
        elif lista1[i] > lista2[j]:
            resultado.append(lista2[j])
            j += 1
        else:
            resultado.append(lista1[i])
            i += 1
            j += 1

    # Agregar elementos restantes
    resultado.extend(lista1[i:])
    resultado.extend(lista2[j:])

    return resultado

# Prueba
print(union_listas_ordenadas([1, 2, 3], [2, 3, 4]))  # [1, 2, 3, 4]

"""### Ejercicio 23. Rotar lista

**Enunciado:** Rota una lista k posiciones a la derecha.
"""

# Ejercicio 23: Rotar lista
# Enunciado: Rota una lista k posiciones a la derecha.
#
# Implementación:

def rotar_lista(lista, k):
    if not lista:
        return lista

    k = k % len(lista)  # Manejar k mayor que longitud
    return lista[-k:] + lista[:-k]

# Prueba
print(rotar_lista([1, 2, 3, 4, 5], 2))  # [4, 5, 1, 2, 3]

"""### Ejercicio 24. Mover ceros al final

**Enunciado:** Mueve todos los ceros al final manteniendo el orden relativo.
"""

# Ejercicio 24: Mover ceros al final
# Enunciado: Mueve todos los ceros al final manteniendo el orden relativo.
#
# Implementación:

def mover_ceros_al_final(lista):
    no_ceros = [x for x in lista if x != 0]
    ceros = [0] * (len(lista) - len(no_ceros))
    return no_ceros + ceros

# Versión in-place
def mover_ceros_al_final_inplace(lista):
    pos = 0
    for i in range(len(lista)):
        if lista[i] != 0:
            lista[pos], lista[i] = lista[i], lista[pos]
            pos += 1

# Prueba
lista = [0, 1, 0, 3, 12]
mover_ceros_al_final_inplace(lista)
print(lista)  # [1, 3, 12, 0, 0]

"""### Ejercicio 25. Encontrar duplicados

**Enunciado:** Encuentra todos los elementos duplicados en una lista.
"""

# Ejercicio 25: Encontrar duplicados
# Enunciado: Encuentra todos los elementos duplicados en una lista.
#
# Implementación:

def encontrar_duplicados(lista):
    vistos = set()
    duplicados = set()

    for elemento in lista:
        if elemento in vistos:
            duplicados.add(elemento)
        else:
            vistos.add(elemento)

    return list(duplicados)

# Prueba
print(encontrar_duplicados([1, 2, 3, 2, 1, 4, 5]))  # [1, 2]

"""### Ejercicio 26. Producto máximo de sublista

**Enunciado:** Encuentra el producto máximo de cualquier sublista contigua.
"""

# Ejercicio 26: Producto máximo de sublista
# Enunciado: Encuentra el producto máximo de cualquier sublista contigua.
#
# Implementación:

def producto_maximo_sublista(lista):
    if not lista:
        return 0

    max_producto = lista[0]
    min_producto = lista[0]
    resultado = lista[0]

    for i in range(1, len(lista)):
        if lista[i] < 0:
            max_producto, min_producto = min_producto, max_producto

        max_producto = max(lista[i], max_producto * lista[i])
        min_producto = min(lista[i], min_producto * lista[i])

        resultado = max(resultado, max_producto)

    return resultado

# Prueba
print(producto_maximo_sublista([2, 3, -2, 4]))  # 6

"""### Ejercicio 27. Lista de Pascal

**Enunciado:** Genera una fila del triángulo de Pascal.
"""

# Ejercicio 27: Lista de Pascal
# Enunciado: Genera una fila del triángulo de Pascal.
#
# Implementación:

def fila_triangulo_pascal(n):
    if n == 0:
        return [1]

    fila_anterior = [1]
    for i in range(1, n + 1):
        fila_actual = [1]
        for j in range(1, i):
            fila_actual.append(fila_anterior[j-1] + fila_anterior[j])
        fila_actual.append(1)
        fila_anterior = fila_actual

    return fila_anterior

# Prueba
print(fila_triangulo_pascal(4))  # [1, 4, 6, 4, 1]

"""### Ejercicio 28. Combinar listas ordenadas

**Enunciado:** Combina k listas ordenadas en una sola lista ordenada.
"""

# Ejercicio 28: Combinar listas ordenadas
# Enunciado: Combina k listas ordenadas en una sola lista ordenada.
#
# Implementación:

import heapq

def combinar_listas_ordenadas(listas):
    heap = []
    resultado = []

    # Insertar primer elemento de cada lista en el heap
    for i, lista in enumerate(listas):
        if lista:
            heapq.heappush(heap, (lista[0], i, 0))

    while heap:
        valor, lista_idx, elem_idx = heapq.heappop(heap)
        resultado.append(valor)

        # Insertar siguiente elemento de la misma lista
        if elem_idx + 1 < len(listas[lista_idx]):
            siguiente_valor = listas[lista_idx][elem_idx + 1]
            heapq.heappush(heap, (siguiente_valor, lista_idx, elem_idx + 1))

    return resultado

# Prueba
print(combinar_listas_ordenadas([[1, 4, 5], [1, 3, 4], [2, 6]]))  # [1, 1, 2, 3, 4, 4, 5, 6]

"""### Ejercicio 29. Subconjuntos

**Enunciado:** Genera todos los subconjuntos posibles de una lista.
"""

# Ejercicio 29: Subconjuntos
# Enunciado: Genera todos los subconjuntos posibles de una lista.
#
# Implementación:

def generar_subconjuntos(lista):
    resultado = [[]]

    for elemento in lista:
        nuevos_subconjuntos = []
        for subconjunto in resultado:
            nuevos_subconjuntos.append(subconjunto + [elemento])
        resultado.extend(nuevos_subconjuntos)

    return resultado

# Prueba
print(generar_subconjuntos([1, 2, 3]))
# [[], [1], [2], [1, 2], [3], [1, 3], [2, 3], [1, 2, 3]]

"""### Ejercicio 30. Mayor rectángulo en histograma

**Enunciado:** Encuentra el área del rectángulo más grande en un histograma.
"""

# Ejercicio 30: Mayor rectángulo en histograma
# Enunciado: Encuentra el área del rectángulo más grande en un histograma.
#
# Implementación:

def mayor_rectangulo_histograma(alturas):
    pila = []
    max_area = 0
    i = 0

    while i < len(alturas):
        if not pila or alturas[i] >= alturas[pila[-1]]:
            pila.append(i)
            i += 1
        else:
            top = pila.pop()
            ancho = i if not pila else i - pila[-1] - 1
            area = alturas[top] * ancho
            max_area = max(max_area, area)

    while pila:
        top = pila.pop()
        ancho = i if not pila else len(alturas) - pila[-1] - 1
        area = alturas[top] * ancho
        max_area = max(max_area, area)

    return max_area

# Prueba
print(mayor_rectangulo_histograma([2, 1, 5, 6, 2, 3]))  # 10

"""### Ejercicio 31. Invertir lista enlazada

**Enunciado:** Invierte una lista enlazada simple.
"""

# Ejercicio 31: Invertir lista enlazada
# Enunciado: Invierte una lista enlazada simple.
#
# Implementación:

class Nodo:
    def __init__(self, valor):
        self.valor = valor
        self.siguiente = None

class ListaEnlazada:
    def __init__(self):
        self.cabeza = None

    def agregar(self, valor):
        nuevo = Nodo(valor)
        if not self.cabeza:
            self.cabeza = nuevo
        else:
            actual = self.cabeza
            while actual.siguiente:
                actual = actual.siguiente
            actual.siguiente = nuevo

    def invertir(self):
        anterior = None
        actual = self.cabeza

        while actual:
            siguiente_temp = actual.siguiente
            actual.siguiente = anterior
            anterior = actual
            actual = siguiente_temp

        self.cabeza = anterior

    def imprimir(self):
        actual = self.cabeza
        while actual:
            print(actual.valor, end=" -> ")
            actual = actual.siguiente
        print("None")

# Prueba
lista = ListaEnlazada()
for i in range(1, 6):
    lista.agregar(i)
lista.invertir()
lista.imprimir()  # 5 -> 4 -> 3 -> 2 -> 1 -> None

"""### Ejercicio 32. Detectar ciclo

**Enunciado:** Detecta si una lista enlazada tiene un ciclo.
"""

# Ejercicio 32: Detectar ciclo
# Enunciado: Detecta si una lista enlazada tiene un ciclo.
#
# Implementación:

def tiene_ciclo(lista):
    if not lista.cabeza:
        return False

    lento = lista.cabeza
    rapido = lista.cabeza

    while rapido and rapido.siguiente:
        lento = lento.siguiente
        rapido = rapido.siguiente.siguiente

        if lento == rapido:
            return True

    return False

# Prueba
lista_ciclica = ListaEnlazada()
nodo1 = Nodo(1)
nodo2 = Nodo(2)
nodo3 = Nodo(3)
nodo1.siguiente = nodo2
nodo2.siguiente = nodo3
nodo3.siguiente = nodo1  # Ciclo
lista_ciclica.cabeza = nodo1
print(tiene_ciclo(lista_ciclica))  # True

"""### Ejercicio 33. Encontrar intersección

**Enunciado:** Encuentra el nodo de intersección de dos listas enlazadas.
"""

# Ejercicio 33: Encontrar intersección
# Enunciado: Encuentra el nodo de intersección de dos listas enlazadas.
#
# Implementación:

def encontrar_interseccion(lista1, lista2):
    if not lista1.cabeza or not lista2.cabeza:
        return None

    # Calcular longitudes
    len1, len2 = 0, 0
    actual1, actual2 = lista1.cabeza, lista2.cabeza

    while actual1:
        len1 += 1
        actual1 = actual1.siguiente

    while actual2:
        len2 += 1
        actual2 = actual2.siguiente

    # Avanzar la lista más larga
    actual1, actual2 = lista1.cabeza, lista2.cabeza
    if len1 > len2:
        for _ in range(len1 - len2):
            actual1 = actual1.siguiente
    else:
        for _ in range(len2 - len1):
            actual2 = actual2.siguiente

    # Encontrar intersección
    while actual1 and actual2:
        if actual1 == actual2:
            return actual1
        actual1 = actual1.siguiente
        actual2 = actual2.siguiente

    return None

"""### Ejercicio 34. Eliminar duplicados

**Enunciado:** Elimina nodos duplicados de una lista enlazada ordenada.
"""

# Ejercicio 34: Eliminar duplicados
# Enunciado: Elimina nodos duplicados de una lista enlazada ordenada.
#
# Implementación:

def eliminar_duplicados_ordenada(lista):
    if not lista.cabeza:
        return

    actual = lista.cabeza
    while actual and actual.siguiente:
        if actual.valor == actual.siguiente.valor:
            actual.siguiente = actual.siguiente.siguiente
        else:
            actual = actual.siguiente

# Prueba
lista = ListaEnlazada()
for valor in [1, 1, 2, 3, 3, 4]:
    lista.agregar(valor)
eliminar_duplicados_ordenada(lista)
lista.imprimir()  # 1 -> 2 -> 3 -> 4 -> None

"""### Ejercicio 35. N-ésimo nodo desde el final

**Enunciado:** Encuentra el n-ésimo nodo desde el final de la lista.
"""

# Ejercicio 35: N-ésimo nodo desde el final
# Enunciado: Encuentra el n-ésimo nodo desde el final de la lista.
#
# Implementación:

def nesimo_desde_final(lista, n):
    if not lista.cabeza or n <= 0:
        return None

    primero = lista.cabeza
    segundo = lista.cabeza

    # Avanzar primero n posiciones
    for _ in range(n):
        if not primero:
            return None
        primero = primero.siguiente

    # Avanzar ambos hasta que primero llegue al final
    while primero:
        primero = primero.siguiente
        segundo = segundo.siguiente

    return segundo.valor if segundo else None

# Prueba
lista = ListaEnlazada()
for i in range(1, 6):
    lista.agregar(i)
print(nesimo_desde_final(lista, 2))  # 4

"""### Ejercicio 36. Suma de números como listas

**Enunciado:** Suma dos números representados como listas enlazadas.
"""

# Ejercicio 36: Suma de números como listas
# Enunciado: Suma dos números representados como listas enlazadas.
#
# Implementación:

def sumar_listas_numeros(lista1, lista2):
    def lista_a_numero(lista):
        num = 0
        actual = lista.cabeza
        while actual:
            num = num * 10 + actual.valor
            actual = actual.siguiente
        return num

    num1 = lista_a_numero(lista1)
    num2 = lista_a_numero(lista2)
    suma = num1 + num2

    # Convertir resultado a lista enlazada
    resultado = ListaEnlazada()
    for digito in str(suma):
        resultado.agregar(int(digito))

    return resultado

# Prueba
lista1 = ListaEnlazada()
lista2 = ListaEnlazada()
for digito in [2, 4, 3]:
    lista1.agregar(digito)
for digito in [5, 6, 4]:
    lista2.agregar(digito)
resultado = sumar_listas_numeros(lista1, lista2)
resultado.imprimir()  # 8 -> 0 -> 7 -> None

"""### Ejercicio 37. Palíndromo en lista enlazada

**Enunciado:** Verifica si una lista enlazada es palíndroma.
"""

# Ejercicio 37: Palíndromo en lista enlazada
# Enunciado: Verifica si una lista enlazada es palíndroma.
#
# Implementación:

def es_palindromo(lista):
    # Encontrar mitad usando técnica de tortuga y liebre
    lento = lista.cabeza
    rapido = lista.cabeza
    pila = []

    while rapido and rapido.siguiente:
        pila.append(lento.valor)
        lento = lento.siguiente
        rapido = rapido.siguiente.siguiente

    # Si la lista tiene longitud impar, saltar el elemento del medio
    if rapido:
        lento = lento.siguiente

    # Comparar con la pila
    while lento:
        if lento.valor != pila.pop():
            return False
        lento = lento.siguiente

    return True

# Prueba
lista_pal = ListaEnlazada()
for valor in [1, 2, 3, 2, 1]:
    lista_pal.agregar(valor)
print(es_palindromo(lista_pal))  # True

"""### Ejercicio 38. Rotar lista enlazada

**Enunciado:** Rota una lista enlazada k posiciones a la derecha.
"""

# Ejercicio 38: Rotar lista enlazada
# Enunciado: Rota una lista enlazada k posiciones a la derecha.
#
# Implementación:

def rotar_lista_enlazada(lista, k):
    if not lista.cabeza or k == 0:
        return

    # Calcular longitud
    longitud = 0
    actual = lista.cabeza
    while actual:
        longitud += 1
        actual = actual.siguiente

    k = k % longitud
    if k == 0:
        return

    # Encontrar nuevo tail y nuevo head
    actual = lista.cabeza
    for _ in range(longitud - k - 1):
        actual = actual.siguiente

    nuevo_head = actual.siguiente
    actual.siguiente = None

    # Conectar el final con la cabeza original
    tail = nuevo_head
    while tail.siguiente:
        tail = tail.siguiente
    tail.siguiente = lista.cabeza
    lista.cabeza = nuevo_head

# Prueba
lista = ListaEnlazada()
for i in range(1, 6):
    lista.agregar(i)
rotar_lista_enlazada(lista, 2)
lista.imprimir()  # 4 -> 5 -> 1 -> 2 -> 3 -> None

"""### Ejercicio 39. Eliminar nodos alternativos

**Enunciado:** Elimina cada segundo nodo de la lista enlazada.
"""

# Ejercicio 39: Eliminar nodos alternativos
# Enunciado: Elimina cada segundo nodo de la lista enlazada.
#
# Implementación:

def eliminar_nodos_alternativos(lista):
    if not lista.cabeza:
        return

    actual = lista.cabeza
    while actual and actual.siguiente:
        actual.siguiente = actual.siguiente.siguiente
        actual = actual.siguiente

# Prueba
lista = ListaEnlazada()
for i in range(1, 7):
    lista.agregar(i)
eliminar_nodos_alternativos(lista)
lista.imprimir()  # 1 -> 3 -> 5 -> None

"""### Ejercicio 40. Punto de unión en Y

**Enunciado:** Encuentra el punto donde dos listas se unen formando una Y.
"""

# Ejercicio 40: Punto de unión en Y
# Enunciado: Encuentra el punto donde dos listas se unen formando una Y.
#
# Implementación:

def encontrar_punto_union(lista1, lista2):
    def obtener_longitud(lista):
        longitud = 0
        actual = lista.cabeza
        while actual:
            longitud += 1
            actual = actual.siguiente
        return longitud

    len1 = obtener_longitud(lista1)
    len2 = obtener_longitud(lista2)

    actual1, actual2 = lista1.cabeza, lista2.cabeza

    # Avanzar la lista más larga
    if len1 > len2:
        for _ in range(len1 - len2):
            actual1 = actual1.siguiente
    else:
        for _ in range(len2 - len1):
            actual2 = actual2.siguiente

    # Encontrar punto de unión
    while actual1 and actual2:
        if actual1 == actual2:
            return actual1
        actual1 = actual1.siguiente
        actual2 = actual2.siguiente

    return None

"""### Ejercicio 41. Implementar LRU Cache

**Enunciado:** Implementa un cache LRU usando lista doblemente enlazada y hash map.
"""

# Ejercicio 41: Implementar LRU Cache
# Enunciado: Implementa un cache LRU usando lista doblemente enlazada y hash map.
#
# Implementación:

class NodoDoble:
    def __init__(self, key, value):
        self.key = key
        self.value = value
        self.siguiente = None
        self.anterior = None

class LRUCache:
    def __init__(self, capacidad):
        self.capacidad = capacidad
        self.cache = {}
        self.head = NodoDoble(0, 0)
        self.tail = NodoDoble(0, 0)
        self.head.siguiente = self.tail
        self.tail.anterior = self.head

    def _agregar_nodo(self, nodo):
        # Agregar después de head
        nodo.siguiente = self.head.siguiente
        nodo.anterior = self.head
        self.head.siguiente.anterior = nodo
        self.head.siguiente = nodo

    def _remover_nodo(self, nodo):
        anterior = nodo.anterior
        siguiente = nodo.siguiente
        anterior.siguiente = siguiente
        siguiente.anterior = anterior

    def _mover_a_frente(self, nodo):
        self._remover_nodo(nodo)
        self._agregar_nodo(nodo)

    def get(self, key):
        if key in self.cache:
            nodo = self.cache[key]
            self._mover_a_frente(nodo)
            return nodo.value
        return -1

    def put(self, key, value):
        if key in self.cache:
            nodo = self.cache[key]
            nodo.value = value
            self._mover_a_frente(nodo)
        else:
            if len(self.cache) >= self.capacidad:
                # Remover el menos recientemente usado
                lru = self.tail.anterior
                self._remover_nodo(lru)
                del self.cache[lru.key]

            nuevo_nodo = NodoDoble(key, value)
            self.cache[key] = nuevo_nodo
            self._agregar_nodo(nuevo_nodo)

# Prueba
cache = LRUCache(2)
cache.put(1, 1)
cache.put(2, 2)
print(cache.get(1))  # 1
cache.put(3, 3)
print(cache.get(2))  # -1

"""### Ejercicio 42. Polinomio con lista doble

**Enunciado:** Representa y suma polinomios usando listas doblemente enlazadas.
"""

# Ejercicio 42: Polinomio con lista doble
# Enunciado: Representa y suma polinomios usando listas doblemente enlazadas.
#
# Implementación:

class Termino:
    def __init__(self, coeficiente, exponente):
        self.coeficiente = coeficiente
        self.exponente = exponente
        self.siguiente = None
        self.anterior = None

class Polinomio:
    def __init__(self):
        self.cabeza = None

    def agregar_termino(self, coeficiente, exponente):
        nuevo = Termino(coeficiente, exponente)
        if not self.cabeza:
            self.cabeza = nuevo
        else:
            actual = self.cabeza
            while actual.siguiente:
                actual = actual.siguiente
            actual.siguiente = nuevo
            nuevo.anterior = actual

    def sumar(self, otro):
        resultado = Polinomio()
        actual1 = self.cabeza
        actual2 = otro.cabeza

        while actual1 and actual2:
            if actual1.exponente == actual2.exponente:
                suma_coef = actual1.coeficiente + actual2.coeficiente
                if suma_coef != 0:
                    resultado.agregar_termino(suma_coef, actual1.exponente)
                actual1 = actual1.siguiente
                actual2 = actual2.siguiente
            elif actual1.exponente > actual2.exponente:
                resultado.agregar_termino(actual1.coeficiente, actual1.exponente)
                actual1 = actual1.siguiente
            else:
                resultado.agregar_termino(actual2.coeficiente, actual2.exponente)
                actual2 = actual2.siguiente

        # Agregar términos restantes
        while actual1:
            resultado.agregar_termino(actual1.coeficiente, actual1.exponente)
            actual1 = actual1.siguiente

        while actual2:
            resultado.agregar_termino(actual2.coeficiente, actual2.exponente)
            actual2 = actual2.siguiente

        return resultado

    def imprimir(self):
        actual = self.cabeza
        while actual:
            print(f"{actual.coeficiente}x^{actual.exponente}", end="")
            if actual.siguiente:
                print(" + ", end="")
            actual = actual.siguiente
        print()

# Prueba
p1 = Polinomio()
p1.agregar_termino(3, 2)
p1.agregar_termino(2, 1)
p1.agregar_termino(1, 0)

p2 = Polinomio()
p2.agregar_termino(2, 2)
p2.agregar_termino(1, 1)

resultado = p1.sumar(p2)
resultado.imprimir()  # 5x^2 + 3x^1 + 1x^0

"""### Ejercicio 43. Navegador web simple

**Enunciado:** Simula las funciones adelante/atrás de un navegador web.
"""

# Ejercicio 43: Navegador web simple
# Enunciado: Simula las funciones adelante/atrás de un navegador web.
#
# Implementación:

class NavegadorWeb:
    def __init__(self):
        self.pagina_actual = None
        self.historial_atras = []
        self.historial_adelante = []

    def visitar_pagina(self, url):
        if self.pagina_actual:
            self.historial_atras.append(self.pagina_actual)
        self.pagina_actual = url
        self.historial_adelante.clear()
        print(f"Visitando: {url}")

    def atras(self):
        if self.historial_atras:
            self.historial_adelante.append(self.pagina_actual)
            self.pagina_actual = self.historial_atras.pop()
            print(f"Yendo atrás a: {self.pagina_actual}")
        else:
            print("No hay páginas anteriores")

    def adelante(self):
        if self.historial_adelante:
            self.historial_atras.append(self.pagina_actual)
            self.pagina_actual = self.historial_adelante.pop()
            print(f"Yendo adelante a: {self.pagina_actual}")
        else:
            print("No hay páginas siguientes")

    def pagina_actual(self):
        return self.pagina_actual

# Prueba
navegador = NavegadorWeb()
navegador.visitar_pagina("google.com")
navegador.visitar_pagina("facebook.com")
navegador.atras()
navegador.adelante()

"""### Ejercicio 44. Playlist de música

**Enunciado:** Implementa una playlist con funciones de next, previous, add, remove.
"""

# Ejercicio 44: Playlist de música
# Enunciado: Implementa una playlist con funciones de next, previous, add, remove.
#
# Implementación:

class Cancion:
    def __init__(self, titulo, artista):
        self.titulo = titulo
        self.artista = artista
        self.siguiente = None
        self.anterior = None

class Playlist:
    def __init__(self):
        self.cabeza = None
        self.cola = None
        self.actual = None

    def agregar_cancion(self, titulo, artista):
        nueva = Cancion(titulo, artista)
        if not self.cabeza:
            self.cabeza = nueva
            self.cola = nueva
            self.actual = nueva
        else:
            self.cola.siguiente = nueva
            nueva.anterior = self.cola
            self.cola = nueva

    def reproducir_siguiente(self):
        if self.actual and self.actual.siguiente:
            self.actual = self.actual.siguiente
            print(f"Reproduciendo: {self.actual.titulo} - {self.actual.artista}")
        else:
            print("No hay siguiente canción")

    def reproducir_anterior(self):
        if self.actual and self.actual.anterior:
            self.actual = self.actual.anterior
            print(f"Reproduciendo: {self.actual.titulo} - {self.actual.artista}")
        else:
            print("No hay canción anterior")

    def eliminar_cancion_actual(self):
        if not self.actual:
            return

        if self.actual.anterior:
            self.actual.anterior.siguiente = self.actual.siguiente
        else:
            self.cabeza = self.actual.siguiente

        if self.actual.siguiente:
            self.actual.siguiente.anterior = self.actual.anterior
        else:
            self.cola = self.actual.anterior

        siguiente = self.actual.siguiente if self.actual.siguiente else self.cabeza
        self.actual = siguiente

    def mostrar_playlist(self):
        actual = self.cabeza
        while actual:
            marcador = " [ACTUAL]" if actual == self.actual else ""
            print(f"{actual.titulo} - {actual.artista}{marcador}")
            actual = actual.siguiente

# Prueba
playlist = Playlist()
playlist.agregar_cancion("Song1", "Artist1")
playlist.agregar_cancion("Song2", "Artist2")
playlist.agregar_cancion("Song3", "Artist3")
playlist.reproducir_siguiente()
playlist.mostrar_playlist()

"""### Ejercicio 45. Texto editor con undo

**Enunciado:** Implementa un editor de texto simple con función deshacer.
"""

# Ejercicio 45: Texto editor con undo
# Enunciado: Implementa un editor de texto simple con función deshacer.
#
# Implementación:

class EstadoTexto:
    def __init__(self, texto):
        self.texto = texto
        self.siguiente = None
        self.anterior = None

class EditorTexto:
    def __init__(self):
        self.estado_actual = EstadoTexto("")
        self.max_historial = 10
        self.contador_estados = 1

    def escribir(self, texto):
        # Crear nuevo estado
        nuevo_estado = EstadoTexto(self.estado_actual.texto + texto)
        nuevo_estado.anterior = self.estado_actual
        self.estado_actual.siguiente = nuevo_estado
        self.estado_actual = nuevo_estado

        # Limitar historial
        self.contador_estados += 1
        if self.contador_estados > self.max_historial:
            # Eliminar el estado más antiguo
            viejo = self.estado_actual
            for _ in range(self.max_historial):
                viejo = viejo.anterior
            viejo.anterior = None

    def deshacer(self):
        if self.estado_actual.anterior:
            self.estado_actual = self.estado_actual.anterior
            return True
        return False

    def rehacer(self):
        if self.estado_actual.siguiente:
            self.estado_actual = self.estado_actual.siguiente
            return True
        return False

    def obtener_texto(self):
        return self.estado_actual.texto

# Prueba
editor = EditorTexto()
editor.escribir("Hola ")
editor.escribir("Mundo")
print(editor.obtener_texto())  # Hola Mundo
editor.deshacer()
print(editor.obtener_texto())  # Hola

"""### Ejercicio 46. Problema de Josephus

**Enunciado:** Resuelve el problema de Josephus usando lista circular.
"""

# Ejercicio 46: Problema de Josephus
# Enunciado: Resuelve el problema de Josephus usando lista circular.
#
# Implementación:

class NodoCircular:
    def __init__(self, valor):
        self.valor = valor
        self.siguiente = None

def problema_josephus(n, k):
    if n == 1:
        return 1

    # Crear lista circular
    cabeza = NodoCircular(1)
    actual = cabeza
    for i in range(2, n + 1):
        actual.siguiente = NodoCircular(i)
        actual = actual.siguiente
    actual.siguiente = cabeza  # Hacer circular

    # Encontrar posición segura
    actual = cabeza
    while actual.siguiente != actual:
        # Saltar k-1 personas
        for _ in range(k - 2):
            actual = actual.siguiente

        # Eliminar siguiente persona
        actual.siguiente = actual.siguiente.siguiente
        actual = actual.siguiente

    return actual.valor

# Prueba
print(problema_josephus(5, 2))  # 3

"""### Ejercicio 47. Lista circular ordenada

**Enunciado:** Inserta elementos en una lista circular manteniéndola ordenada.
"""

# Ejercicio 47: Lista circular ordenada
# Enunciado: Inserta elementos en una lista circular manteniéndola ordenada.
#
# Implementación:

class ListaCircularOrdenada:
    def __init__(self):
        self.cabeza = None

    def insertar_ordenado(self, valor):
        nuevo = NodoCircular(valor)

        # Caso 1: Lista vacía
        if not self.cabeza:
            self.cabeza = nuevo
            nuevo.siguiente = nuevo
            return

        # Caso 2: Insertar antes de la cabeza
        if valor < self.cabeza.valor:
            # Encontrar cola
            cola = self.cabeza
            while cola.siguiente != self.cabeza:
                cola = cola.siguiente

            nuevo.siguiente = self.cabeza
            cola.siguiente = nuevo
            self.cabeza = nuevo
            return

        # Caso 3: Insertar en medio o al final
        actual = self.cabeza
        while actual.siguiente != self.cabeza and actual.siguiente.valor < valor:
            actual = actual.siguiente

        nuevo.siguiente = actual.siguiente
        actual.siguiente = nuevo

    def imprimir(self):
        if not self.cabeza:
            return

        actual = self.cabeza
        while True:
            print(actual.valor, end=" -> ")
            actual = actual.siguiente
            if actual == self.cabeza:
                break
        print("(cabeza)")

# Prueba
lista = ListaCircularOrdenada()
lista.insertar_ordenado(3)
lista.insertar_ordenado(1)
lista.insertar_ordenado(2)
lista.imprimir()  # 1 -> 2 -> 3 -> (cabeza)

"""### Ejercicio 48. Dividir lista circular

**Enunciado:** Divide una lista circular en dos mitades iguales.
"""

# Ejercicio 48: Dividir lista circular
# Enunciado: Divide una lista circular en dos mitades iguales.
#
# Implementación:

def dividir_lista_circular(lista):
    if not lista.cabeza or lista.cabeza.siguiente == lista.cabeza:
        return lista, None

    # Encontrar punto medio con técnica de tortuga y liebre
    tortuga = lista.cabeza
    liebre = lista.cabeza

    while liebre.siguiente != lista.cabeza and liebre.siguiente.siguiente != lista.cabeza:
        tortuga = tortuga.siguiente
        liebre = liebre.siguiente.siguiente

    # Crear segunda lista
    cabeza2 = tortuga.siguiente
    tortuga.siguiente = lista.cabeza

    # Hacer circular la segunda lista
    actual = cabeza2
    while actual.siguiente != lista.cabeza:
        actual = actual.siguiente
    actual.siguiente = cabeza2

    # Crear nueva lista para la segunda mitad
    lista2 = ListaCircularOrdenada()
    lista2.cabeza = cabeza2

    return lista, lista2

# Prueba
lista = ListaCircularOrdenada()
for i in range(1, 6):
    lista.insertar_ordenado(i)
lista1, lista2 = dividir_lista_circular(lista)
lista1.imprimir()
lista2.imprimir()

"""### Ejercicio 49. Verificar lista circular

**Enunciado:** Verifica si una lista enlazada es circular.
"""

# Ejercicio 49: Verificar lista circular
# Enunciado: Verifica si una lista enlazada es circular.
#
# Implementación:

def es_lista_circular(lista):
    if not lista.cabeza:
        return False

    tortuga = lista.cabeza
    liebre = lista.cabeza

    while liebre and liebre.siguiente:
        tortuga = tortuga.siguiente
        liebre = liebre.siguiente.siguiente

        if tortuga == liebre:
            return True

    return False

# Prueba
lista_circular = ListaCircularOrdenada()
lista_circular.insertar_ordenado(1)
lista_circular.insertar_ordenado(2)
print(es_lista_circular(lista_circular))  # True

"""### Ejercicio 50. Rotar lista circular

**Enunciado:** Rota una lista circular k posiciones.
"""

# Ejercicio 50: Rotar lista circular
# Enunciado: Rota una lista circular k posiciones.
#
# Implementación:

def rotar_lista_circular(lista, k):
    if not lista.cabeza or k == 0:
        return

    # Encontrar longitud
    longitud = 1
    actual = lista.cabeza
    while actual.siguiente != lista.cabeza:
        longitud += 1
        actual = actual.siguiente

    k = k % longitud
    if k == 0:
        return

    # Encontrar nueva cabeza
    actual = lista.cabeza
    for _ in range(longitud - k - 1):
        actual = actual.siguiente

    lista.cabeza = actual.siguiente

# Prueba
lista = ListaCircularOrdenada()
for i in range(1, 6):
    lista.insertar_ordenado(i)
rotar_lista_circular(lista, 2)
lista.imprimir()